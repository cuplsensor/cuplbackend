# -*- coding: utf-8 -*-
"""
Created on 29 July 2012
@author: Lisa Simpson
"""

"""
    web.tags
    ~~~~~~~~~~

    tags package
"""

from ..core import Service
from .models import Tag

from hashids import Hashids
from flask import current_app
from .simsamples import trhsamples
from wscodec.encoder.pyencoder.instrumented import InstrumentedSampleTRH

from random import getrandbits
import base64


class TagDecodeFailedError(Exception):
    """ Tag Decode Failed Error

    The tag serial number did not decode to the tag id
    """

    def __init__(self, tagid, serial, decoded):
        self.description = "Tag serial number {} for tag id {} decodes to {}".format(serial, tagid, decoded)

    def __str__(self):
        return self.description


class TagService(Service):
    __model__ = Tag
    hashids = Hashids(min_length=8, salt="this is my salt")

    def get_by_serial(self, serial):
        """Return the first instance of a tag in the database with
        with the given serial.
        There will only be one because because serial is unique.
        :param serial: 6 character base 32 serial number
        """
        return self.first_or_404(serial=serial)

    def gen_secret_key(self):
        """Generate a random secret key.
        """
        bitsperbyte = 8
        skeyintlenbytes = 6
        # Generate a random integer of 6 bytes * 8 bits.
        skeyint = getrandbits(bitsperbyte * skeyintlenbytes)
        # Convert the random integer into a bytes object
        skeybytes = skeyint.to_bytes(skeyintlenbytes, byteorder='big')
        # Convert the bytes object into a base 64 string.
        skeyb64 = base64.urlsafe_b64encode(skeybytes)
        return skeyb64.decode("utf-8")

    def create(self, **kwargs):
        """Returns a new, saved instance of the tag model class.
        :param **kwargs: instance parameters
        """
        # Call base class constructor. By committing to the db we get an id.
        tag = super().create(**kwargs)
        # Generate a serial from the id.
        serial = self.hashids.encode(tag.id)
        # Make sure that the serial decodes back to the id
        serialdecoded = self.hashids.decode(serial)[0]
        if (tag.id != serialdecoded):
            raise TagDecodeFailedError(tag.id, serial, serialdecoded)

        if 'serial' in kwargs:
            serialb64 = kwargs['serial']
        else:
            serialb64 = serial

        # Generate a secret key base64 string.
        if 'secretkey' in kwargs:
            seckeyb64 = kwargs['secretkey']
        else:
            seckeyb64 = self.gen_secret_key()

        # Assign serial to the tag and commit to the db.
        return super().update(tag, serial=serialb64, secretkey=seckeyb64)

    def simulate(self, id, frontendurl, nsamples=100):
        """ Get URL that would be generated by a tag. """
        # Get tag from the database so we can obtain its serial and secretkey
        tag = self.get(id=id)
        smplintervalmins = 10

        # Disable https if necessary
        spliturl = frontendurl.split('://')
        httpsdisable = False  # Assume https by default

        if spliturl[0] == "http":
            httpsdisable = True
            frontendurl = spliturl[1]  # Remove protocol from the URL
        elif spliturl[0] == "https":
            frontendurl = spliturl[1]   # Remove protocol from the URL

        # Initialise encoder
        virtualsensor = InstrumentedSampleTRH(baseurl=frontendurl,
                                              serial=tag.serial,
                                              secretkey=tag.secretkey,
                                              smplintervalmins=smplintervalmins,
                                              httpsdisable=httpsdisable)

        # Produce a list of simulated samples. Each is a dictionary with temp and rh keys.
        # Also store the time offset from UTC now to the most recent sample.
        trhlist, timeoffsetmins = trhsamples(smplintervalmins=smplintervalmins, nsamples=nsamples)

        # Load samples into wscodec
        virtualsensor.pushsamplelist(trhlist)

        # Update time offset on the virtual sensor in minutes
        virtualsensor.updateendstop(timeoffsetmins)

        # Obtain URL
        urlstr = virtualsensor.get_url()

        return urlstr
